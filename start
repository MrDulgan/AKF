#!/bin/bash

# Enhanced AK Server Startup Script
# Developer: Dulgan

# Color codes
GREEN='\e[1;32m'
BLUE='\e[0;36m'
RED='\e[0;31m'
YELLOW='\e[1;33m'
PURPLE='\e[0;35m'
NC='\e[0m' # No Color

# Configuration
INSTALL_DIR="/root/hxsy"
MAX_STARTUP_TIME=30
HEALTH_CHECK_INTERVAL=2
DATABASE_CHECK_TIMEOUT=10

# Multi-server configuration
declare -A SERVER_INSTANCES
declare -A SERVER_PIDS
STARTUP_MODE="single"  # single, multi, selective

# Set locale
export LC_ALL=C

# ============================================
# FUNCTION DEFINITIONS
# ============================================

# Enhanced server health check
check_server_health() {
    local server_name="$1"
    local pid="$2"
    local max_checks=10
    local check_count=0
    
    while [ $check_count -lt $max_checks ]; do
        if ps -p "$pid" > /dev/null 2>&1; then
            # Check if process is actually working (not zombie)
            local proc_stat=$(cat "/proc/$pid/stat" 2>/dev/null | awk '{print $3}')
            if [[ "$proc_stat" != "Z" ]]; then
                return 0  # Healthy
            fi
        fi
        sleep $HEALTH_CHECK_INTERVAL
        check_count=$((check_count + 1))
    done
    return 1  # Unhealthy
}

# Function to start a server with enhanced monitoring
start_server() {
    local server_path="$1"
    local server_exec="$2"
    local port="$3"
    local instance_name="${4:-default}"

    echo -e "${BLUE}>> Starting $server_exec ($instance_name)...${NC}" | tee -a "$LOGFILE"
    
    cd "$server_path" || { echo -e "${RED}>> Cannot access $server_path.${NC}" | tee -a "$LOGFILE"; return 1; }
    chmod 755 "$server_exec" 2>/dev/null

    # Check if server is already running
    if pgrep -f "$server_path.*$server_exec" > /dev/null; then
        echo -e "${YELLOW}>> $server_exec ($instance_name) is already running. Skipping start.${NC}" | tee -a "$LOGFILE"
        return
    fi

    # Verify server binary exists and is executable
    if [[ ! -x "./$server_exec" ]]; then
        echo -e "${RED}>> Server binary $server_exec not found or not executable in $server_path.${NC}" | tee -a "$LOGFILE"
        return 1
    fi

    # Start server with optional port
    if [[ -n "$port" ]]; then
        echo -e "${BLUE}   - Starting with port $port...${NC}" | tee -a "$LOGFILE"
        nohup ./"$server_exec" -p "$port" >>"$LOGFILE" 2>&1 &
    else
        nohup ./"$server_exec" >>"$LOGFILE" 2>&1 &
    fi

    local pid=$!
    SERVER_PIDS["${instance_name}-${server_exec}"]=$pid

    # Enhanced health check
    if check_server_health "$server_exec" "$pid"; then
        echo -e "${GREEN}>> $server_exec started successfully with PID $pid.${NC}" | tee -a "$LOGFILE"
        
        # Additional port verification if specified
        if [[ -n "$port" ]]; then
            sleep 3
            if ss -tuln | grep ":$port " > /dev/null 2>&1; then
                echo -e "${GREEN}   - Port $port is listening.${NC}" | tee -a "$LOGFILE"
            else
                echo -e "${YELLOW}   - Warning: Port $port is not listening yet.${NC}" | tee -a "$LOGFILE"
            fi
        fi
    else
        echo -e "${RED}>> $server_exec failed to start or is unhealthy.${NC}" | tee -a "$LOGFILE"
        exit 1
    fi
    
    # Wait between server starts for stability
    sleep 5
}

# Save PID information for all instances
save_pid_information() {
    # Save to default instance directory
    cat > "$INSTALL_DIR/.server_pids" << EOF
# Multi-Server PID information - $(date)
# Startup Mode: $STARTUP_MODE
# Format: INSTANCE-SERVER=PID
$(for server in "${!SERVER_PIDS[@]}"; do echo "$server=${SERVER_PIDS[$server]}"; done)
EOF

    # Save to each instance directory
    for instance in "${!SERVER_INSTANCES[@]}"; do
        local instance_dir="${SERVER_INSTANCES[$instance]}"
        if [[ "$instance_dir" != "$INSTALL_DIR" ]]; then
            cat > "$instance_dir/.server_pids" << EOF
# Server PID information for $instance - $(date)
# Startup Mode: $STARTUP_MODE
$(for server in "${!SERVER_PIDS[@]}"; do 
    if [[ "$server" == "$instance"-* ]]; then
        echo "$server=${SERVER_PIDS[$server]}"
    fi
done)
EOF
        fi
    done
    
    echo -e "${BLUE}>> Server PID information saved to instance directories${NC}"
}

# Final status and management information
display_final_status() {
    echo -e "${PURPLE}
==================================================
            Server Startup Complete!
==================================================${NC}"
    
    case "$STARTUP_MODE" in
        "single")
            echo -e "${GREEN}>> Default server instance is now running.${NC}"
            ;;
        "multi")
            echo -e "${GREEN}>> All ${#SERVER_INSTANCES[@]} server instances are now running.${NC}"
            ;;
        "selective")
            echo -e "${GREEN}>> Selected server instances are now running.${NC}"
            ;;
    esac
    
    echo -e "${BLUE}>> Server logs are being written to individual instance log directories${NC}"
    
    echo -e "${YELLOW}
>> Management Tools Available:${NC}"
    echo -e "${GREEN}   • Enhanced monitor (multi-server) : ./monitor.sh${NC}"
    echo -e "${GREEN}   • Backup server data              : ./backup.sh${NC}"
    echo -e "${GREEN}   • Restore server data             : ./restore.sh${NC}"
    echo -e "${GREEN}   • Create game accounts            : ./account_creator.sh${NC}"
    echo -e "${GREEN}   • AKUTools suite                 : ./akutools${NC}"
    echo -e "${GREEN}   • Stop servers                   : ./stop${NC}"

    # Check if AKUTools is available
    if [ -f "./akutools" ]; then
        echo -e "${BLUE}
>> Advanced Management (AKUTools):${NC}"
        echo -e "${GREEN}   • Multi-server management  : /root/AKUTools/multi_server_manager.sh${NC}"
        echo -e "${GREEN}   • Multi-channel management : /root/AKUTools/multi_channel_manager.sh${NC}"
        echo -e "${GREEN}   • Enhanced monitoring      : Monitor with 'i' key to switch instances${NC}"
    fi

    echo -e "${PURPLE}
>> The servers are now running in the background.
>> You can safely close this terminal or use it for other tasks.
>> Use './stop' to shutdown servers when needed.
==================================================${NC}"

    # Quick server status check for all instances
    echo -e "${BLUE}>> Quick Status Check:${NC}"
    local total_active_servers=0
    local total_expected_servers=0
    
    for instance in "${!SERVER_INSTANCES[@]}"; do
        local instance_dir="${SERVER_INSTANCES[$instance]}"
        local instance_active=0
        local instance_expected=6  # Basic server count
        
        echo -e "${CYAN}   Instance: $instance${NC}"
        
        # Check basic servers
        for server_type in TicketServer GatewayServer LoginServer MissionServer WorldServer ZoneServer; do
            local server_key="${instance}-${server_type}"
            if [[ -n "${SERVER_PIDS[$server_key]}" ]]; then
                local pid=${SERVER_PIDS[$server_key]}
                if ps -p $pid > /dev/null 2>&1; then
                    echo -e "${GREEN}     ✓ $server_type (PID: $pid)${NC}"
                    ((instance_active++))
                    ((total_active_servers++))
                else
                    echo -e "${RED}     ✗ $server_type (not running)${NC}"
                fi
                ((total_expected_servers++))
            fi
        done
        
        # Check channel servers
        for channel_dir in "$instance_dir"/Channel_*; do
            if [[ -d "$channel_dir" ]]; then
                local channel_name=$(basename "$channel_dir")
                for server_type in ZoneServer WorldServer; do
                    local server_key="${instance}-${channel_name}-${server_type}"
                    if [[ -n "${SERVER_PIDS[$server_key]}" ]]; then
                        local pid=${SERVER_PIDS[$server_key]}
                        if ps -p $pid > /dev/null 2>&1; then
                            echo -e "${GREEN}     ✓ $channel_name-$server_type (PID: $pid)${NC}"
                            ((instance_active++))
                            ((total_active_servers++))
                        else
                            echo -e "${RED}     ✗ $channel_name-$server_type (not running)${NC}"
                        fi
                        ((total_expected_servers++))
                    fi
                done
            fi
        done
        
        echo -e "${BLUE}     Instance status: $instance_active servers running${NC}"
    done

    echo -e "${GREEN}>> Total: $total_active_servers out of $total_expected_servers servers are running.${NC}"

    # Save PID information for management scripts
    save_pid_information
    
    echo -e "${BLUE}>> Server startup mode: $STARTUP_MODE${NC}"
    echo -e "${BLUE}>> Use enhanced monitor (./monitor.sh) to switch between instances${NC}"
    echo -e "${YELLOW}>> Happy gaming! The servers are ready for connections.${NC}"
}

# ============================================
# MAIN SCRIPT EXECUTION
# ============================================

# Set locale
export LC_ALL=C

# Detect available server instances
detect_server_instances() {
    echo -e "${BLUE}>> Detecting server instances...${NC}"
    
    # Always include the default instance if it has server files
    if [[ -d "$INSTALL_DIR" ]]; then
        # Check for server executables
        local has_servers=false
        for server_file in TicketServer AccountServer LoginServer WorldServer ZoneServer GatewayServer MissionServer; do
            if [[ -f "$INSTALL_DIR/$server_file" && -x "$INSTALL_DIR/$server_file" ]]; then
                has_servers=true
                break
            fi
        done
        
        if [[ "$has_servers" == "true" ]]; then
            SERVER_INSTANCES["default"]="$INSTALL_DIR"
            echo -e "${GREEN}   - Found default instance: $INSTALL_DIR${NC}"
        else
            echo -e "${YELLOW}   - Default directory exists but no server executables found${NC}"
        fi
    fi
    
    # Check for additional server instances (hxsy_* and hxsy-*)
    for dir in /root/hxsy_* /root/hxsy-*; do
        if [[ -d "$dir" && "$dir" != "$INSTALL_DIR" ]]; then
            # Check for server executables
            local has_servers=false
            for server_file in TicketServer AccountServer LoginServer WorldServer ZoneServer GatewayServer MissionServer; do
                if [[ -f "$dir/$server_file" && -x "$dir/$server_file" ]]; then
                    has_servers=true
                    break
                fi
            done
            
            if [[ "$has_servers" == "true" ]]; then
                local instance_name=$(basename "$dir")
                # Clean up instance name (remove hxsy_ or hxsy- prefix)
                if [[ "$instance_name" == hxsy_* ]]; then
                    instance_name=${instance_name#hxsy_}
                elif [[ "$instance_name" == hxsy-* ]]; then
                    instance_name=${instance_name#hxsy-}
                fi
                SERVER_INSTANCES["$instance_name"]="$dir"
                echo -e "${GREEN}   - Found instance: $instance_name ($dir)${NC}"
            else
                echo -e "${YELLOW}   - Directory $dir exists but no server executables found${NC}"
            fi
        fi
    done
    
    # Check AKUTools directory for server configurations
    if [[ -d "/root/AKUTools" ]]; then
        for config in /root/AKUTools/server_*.conf; do
            if [[ -f "$config" ]]; then
                local instance_name=$(basename "$config" .conf | sed 's/server_//')
                local server_path=$(grep "INSTALL_DIR=" "$config" 2>/dev/null | cut -d'=' -f2)
                if [[ -n "$server_path" && -d "$server_path" ]]; then
                    SERVER_INSTANCES["$instance_name"]="$server_path"
                    echo -e "${GREEN}   - Found configured instance: $instance_name ($server_path)${NC}"
                fi
            fi
        done
    fi
    
    echo -e "${BLUE}>> Total server instances detected: ${#SERVER_INSTANCES[@]}${NC}"
}

# Check for multi-channel configuration within an instance
check_multi_channel() {
    local instance_dir="$1"
    local instance_name="$2"
    
    echo -e "${BLUE}>> Checking multi-channel configuration for $instance_name...${NC}"
    local channel_configs=()
    
    # Find all channel configuration files
    for config in "$instance_dir"/config_channel_*.ini; do
        if [[ -f "$config" ]]; then
            channel_configs+=("$config")
        fi
    done
    
    # Check for Channel directories
    for dir in "$instance_dir"/Channel_*; do
        if [[ -d "$dir" ]]; then
            local channel_name=$(basename "$dir")
            echo -e "${GREEN}   - Found channel directory: $channel_name${NC}"
        fi
    done
    
    if [[ ${#channel_configs[@]} -gt 0 ]]; then
        echo -e "${GREEN}>> Found ${#channel_configs[@]} additional channel config(s) for $instance_name:${NC}"
        for config in "${channel_configs[@]}"; do
            local channel_name=$(basename "$config" .ini | sed 's/config_channel_/Channel /')
            echo -e "${GREEN}   - $channel_name${NC}"
        done
        echo -e "${YELLOW}>> Note: Multi-channel support active for $instance_name.${NC}"
        return 0
    else
        echo -e "${BLUE}>> Single channel mode for $instance_name (Aurora-Ch01 only).${NC}"
        return 1
    fi
}

# Ask user about startup mode
select_startup_mode() {
    if [[ ${#SERVER_INSTANCES[@]} -eq 1 ]]; then
        STARTUP_MODE="single"
        echo -e "${BLUE}>> Single server instance detected. Starting in single mode.${NC}"
        return
    fi
    
    echo -e "${CYAN}
==================================================
           Multi-Server Startup Options
==================================================${NC}"
    echo -e "${GREEN}Available server instances:${NC}"
    local counter=1
    for instance in "${!SERVER_INSTANCES[@]}"; do
        echo -e "  [$counter] $instance - ${SERVER_INSTANCES[$instance]}"
        ((counter++))
    done
    
    echo -e "\n${YELLOW}Startup options:${NC}"
    echo -e "  [1] Start ALL server instances"
    echo -e "  [2] Start ONLY default instance (${INSTALL_DIR})"
    echo -e "  [3] Select specific instances to start"
    echo -e "  [4] Show details and decide"
    
    read -p "$(echo -e ${BLUE}Select startup mode [1-4]: ${NC})" choice
    
    case $choice in
        1)
            STARTUP_MODE="multi"
            echo -e "${GREEN}>> Selected: Start ALL server instances${NC}"
            ;;
        2)
            STARTUP_MODE="single"
            echo -e "${GREEN}>> Selected: Start ONLY default instance${NC}"
            ;;
        3)
            STARTUP_MODE="selective"
            echo -e "${GREEN}>> Selected: Selective instance startup${NC}"
            ;;
        4)
            show_instance_details
            select_startup_mode
            return
            ;;
        *)
            echo -e "${YELLOW}>> Invalid choice. Defaulting to single instance mode.${NC}"
            STARTUP_MODE="single"
            ;;
    esac
}

# Show detailed instance information
show_instance_details() {
    echo -e "${CYAN}
==================================================
           Server Instance Details
==================================================${NC}"
    
    for instance in "${!SERVER_INSTANCES[@]}"; do
        local instance_dir="${SERVER_INSTANCES[$instance]}"
        echo -e "\n${GREEN}Instance: $instance${NC}"
        echo -e "  Path: $instance_dir"
        
        # Check if servers exist
        local servers=("TicketServer" "GatewayServer" "LoginServer" "MissionServer" "WorldServer" "ZoneServer")
        local server_count=0
        for server in "${servers[@]}"; do
            if [[ -d "$instance_dir/$server" ]]; then
                ((server_count++))
            fi
        done
        echo -e "  Server components: $server_count/6"
        
        # Check for multi-channel
        if check_multi_channel "$instance_dir" "$instance" >/dev/null 2>&1; then
            echo -e "  Multi-channel: ${GREEN}Yes${NC}"
        else
            echo -e "  Multi-channel: ${YELLOW}No${NC}"
        fi
        
        # Check if currently running
        local running_servers=0
        for server in "${servers[@]}"; do
            if pgrep -f "$instance_dir/$server" > /dev/null; then
                ((running_servers++))
            fi
        done
        
        if [[ $running_servers -gt 0 ]]; then
            echo -e "  Status: ${YELLOW}$running_servers/$server_count servers running${NC}"
        else
            echo -e "  Status: ${BLUE}Stopped${NC}"
        fi
    done
    
    echo -e "\n${BLUE}Press Enter to continue...${NC}"
    read
}

# Dependency check
check_dependencies() {
    echo -e "${BLUE}>> Checking system dependencies...${NC}"
    local missing=0
    
    for cmd in psql pgrep pkill ss; do
        if ! command -v "$cmd" &> /dev/null; then
            echo -e "${RED}- Command '$cmd' not found.${NC}"
            missing=1
        fi
    done
    
    if [ "$missing" -eq 1 ]; then
        echo -e "${RED}[ERROR] Missing required dependencies. Please install them.${NC}"
        exit 1
    fi
    echo -e "${GREEN}>> Dependencies check passed.${NC}"
}

# Database connectivity check
check_database_connection() {
    echo -e "${BLUE}>> Checking database connectivity...${NC}"
    local config_file="$INSTALL_DIR/setup.ini"
    
    if [[ -f "$config_file" ]]; then
        local db_pass=$(grep "^AccountDBPW=" "$config_file" | cut -d'=' -f2- | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        if [[ -n "$db_pass" ]]; then
            local timeout_cmd="timeout $DATABASE_CHECK_TIMEOUT"
            if $timeout_cmd bash -c "PGPASSWORD='$db_pass' psql -U postgres -h localhost -d FFAccount -c 'SELECT 1;' >/dev/null 2>&1"; then
                echo -e "${GREEN}>> Database connection successful.${NC}"
                return 0
            else
                echo -e "${YELLOW}[WARNING] Database connection failed. Servers may not start properly.${NC}"
                return 1
            fi
        else
            echo -e "${YELLOW}[WARNING] Database password not found in config.${NC}"
            return 1
        fi
    else
        echo -e "${YELLOW}[WARNING] Configuration file not found: $config_file${NC}"
        return 1
    fi
}

# System resource check
check_system_resources() {
    echo -e "${BLUE}>> Checking system resources...${NC}"
    
    # Memory check (at least 2GB available)
    local available_mem=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    local required_mem=2097152  # 2GB in KB
    
    if [[ "$available_mem" -lt "$required_mem" ]]; then
        echo -e "${YELLOW}[WARNING] Low memory: $(($available_mem/1024))MB available, 2GB recommended.${NC}"
    else
        echo -e "${GREEN}>> Memory check passed: $(($available_mem/1024))MB available.${NC}"
    fi
    
    # Disk space check
    local available_disk=$(df "$INSTALL_DIR" | tail -1 | awk '{print $4}')
    local required_disk=1048576  # 1GB in KB
    
    if [[ "$available_disk" -lt "$required_disk" ]]; then
        echo -e "${YELLOW}[WARNING] Low disk space: $(($available_disk/1024))MB available.${NC}"
    else
        echo -e "${GREEN}>> Disk space check passed: $(($available_disk/1024))MB available.${NC}"
    fi
}

# Enhanced log directory setup
setup_logging() {
    local log_dir="$INSTALL_DIR/Logs/Startup"
    if [ ! -d "$log_dir" ]; then
        mkdir -p "$log_dir" || { echo -e "${RED}>> Failed to create log directory.${NC}"; exit 1; }
        echo -e "${GREEN}>> Startup directory created: $log_dir${NC}"
    else
        echo -e "${BLUE}>> Startup directory exists: $log_dir${NC}"
    fi

    # Define log file with timestamp
    LOGFILE="$log_dir/startup_logs_$(date +%Y%m%d_%H%M%S).log"
    touch "$LOGFILE"
    
    # Clean old log files (keep last 10)
    find "$log_dir" -name "startup_logs_*.log" -type f | sort -r | tail -n +11 | xargs rm -f 2>/dev/null
}

# Introductory message
echo -e "${PURPLE}=================================================="
echo -e "         Enhanced AK Server Startup Script       "
echo -e "               Developer: Dulgan                 "
echo -e "==================================================${NC}"

# Pre-flight checks
check_dependencies
check_system_resources
setup_logging
check_database_connection

echo | tee -a "$LOGFILE"  # Start logging after LOGFILE is defined

# Detect and configure multi-server startup
detect_server_instances
if [[ ${#SERVER_INSTANCES[@]} -gt 1 ]]; then
    select_startup_mode
else
    STARTUP_MODE="single"
    echo -e "${BLUE}>> Single server instance detected. Starting in single mode.${NC}" | tee -a "$LOGFILE"
fi

# Stop any running servers before starting (based on startup mode)
stop_existing_servers() {
    echo -e "${BLUE}>> Stopping any existing server processes...${NC}" | tee -a "$LOGFILE"
    
    if [[ "$STARTUP_MODE" == "single" ]]; then
        # Stop only default instance servers
        for srv in ZoneServer WorldServer MissionServer LoginServer GatewayServer TicketServer; do
            if pgrep -f "$INSTALL_DIR.*$srv" > /dev/null; then
                echo -e "${YELLOW}   - Stopping existing $srv process (default instance)...${NC}" | tee -a "$LOGFILE"
                pkill -TERM -f "$INSTALL_DIR.*$srv" 2>/dev/null
                sleep 1
            fi
        done
    else
        # Stop all server processes across all instances
        for srv in ZoneServer WorldServer MissionServer LoginServer GatewayServer TicketServer; do
            if pgrep -f "$srv" > /dev/null; then
                echo -e "${YELLOW}   - Stopping existing $srv processes (all instances)...${NC}" | tee -a "$LOGFILE"
                pkill -TERM -f "$srv" 2>/dev/null
                sleep 1
            fi
        done
    fi
    
    # Force kill any remaining processes
    sleep 2
    for srv in ZoneServer WorldServer MissionServer LoginServer GatewayServer TicketServer; do
        if pgrep -f "$srv" > /dev/null; then
            pkill -KILL -f "$srv" 2>/dev/null
        fi
    done
    sleep 3
}

stop_existing_servers

# Start server instances based on selected mode
start_server_instances() {
    local START_TIME=$(date +%s)
    local total_servers_started=0
    
    case "$STARTUP_MODE" in
        "single")
            echo -e "${GREEN}>> Starting default server instance...${NC}" | tee -a "$LOGFILE"
            start_single_instance "$INSTALL_DIR" "default"
            total_servers_started=6
            ;;
        "multi")
            echo -e "${GREEN}>> Starting ALL server instances...${NC}" | tee -a "$LOGFILE"
            for instance in "${!SERVER_INSTANCES[@]}"; do
                local instance_dir="${SERVER_INSTANCES[$instance]}"
                echo -e "${CYAN}>> Starting instance: $instance ($instance_dir)${NC}" | tee -a "$LOGFILE"
                start_single_instance "$instance_dir" "$instance"
                ((total_servers_started += 6))
                echo -e "${GREEN}   - Instance $instance started successfully${NC}" | tee -a "$LOGFILE"
                sleep 2  # Brief pause between instances
            done
            ;;
        "selective")
            echo -e "${GREEN}>> Starting selected server instances...${NC}" | tee -a "$LOGFILE"
            select_instances_to_start
            ;;
    esac
    
    echo -e "${GREEN}>> Server startup completed in $(($(date +%s) - START_TIME)) seconds.${NC}" | tee -a "$LOGFILE"
    echo -e "${BLUE}>> Total servers started: $total_servers_started${NC}" | tee -a "$LOGFILE"
}

# Start a single server instance
start_single_instance() {
    local instance_dir="$1"
    local instance_name="$2"
    
    echo -e "${BLUE}   - Starting servers for $instance_name...${NC}" | tee -a "$LOGFILE"
    
    # Check for multi-channel configuration
    check_multi_channel "$instance_dir" "$instance_name"
    
    # Start servers in dependency order
    start_server "$instance_dir/TicketServer/" "TicketServer" "7777" "$instance_name"
    start_server "$instance_dir/GatewayServer/" "GatewayServer" "" "$instance_name"
    start_server "$instance_dir/LoginServer/" "LoginServer" "" "$instance_name"
    start_server "$instance_dir/MissionServer/" "MissionServer" "" "$instance_name"
    start_server "$instance_dir/WorldServer/" "WorldServer" "" "$instance_name"
    start_server "$instance_dir/ZoneServer/" "ZoneServer" "" "$instance_name"
    
    # Start additional channel servers if they exist
    for channel_dir in "$instance_dir"/Channel_*; do
        if [[ -d "$channel_dir" ]]; then
            local channel_name=$(basename "$channel_dir")
            echo -e "${CYAN}   - Starting $channel_name servers...${NC}" | tee -a "$LOGFILE"
            
            # Start channel-specific servers
            if [[ -f "$channel_dir/ZoneServer" ]]; then
                start_server "$channel_dir/" "ZoneServer" "" "$instance_name-$channel_name"
            fi
            if [[ -f "$channel_dir/WorldServer" ]]; then
                start_server "$channel_dir/" "WorldServer" "" "$instance_name-$channel_name"
            fi
        fi
    done
}

# Select specific instances to start
select_instances_to_start() {
    echo -e "${CYAN}Select instances to start (space-separated numbers or 'all'):${NC}"
    local counter=1
    declare -a instance_list
    
    for instance in "${!SERVER_INSTANCES[@]}"; do
        echo -e "  [$counter] $instance - ${SERVER_INSTANCES[$instance]}"
        instance_list[$counter]="$instance"
        ((counter++))
    done
    
    read -p "$(echo -e ${BLUE}Enter selections: ${NC})" selections
    
    if [[ "$selections" == "all" ]]; then
        for instance in "${!SERVER_INSTANCES[@]}"; do
            local instance_dir="${SERVER_INSTANCES[$instance]}"
            echo -e "${CYAN}>> Starting instance: $instance ($instance_dir)${NC}" | tee -a "$LOGFILE"
            start_single_instance "$instance_dir" "$instance"
        done
    else
        for selection in $selections; do
            if [[ "$selection" =~ ^[0-9]+$ ]] && [[ -n "${instance_list[$selection]}" ]]; then
                local instance="${instance_list[$selection]}"
                local instance_dir="${SERVER_INSTANCES[$instance]}"
                echo -e "${CYAN}>> Starting selected instance: $instance ($instance_dir)${NC}" | tee -a "$LOGFILE"
                start_single_instance "$instance_dir" "$instance"
            fi
        done
    fi
}

# Function to handle CTRL+C
trap_ctrlc() {
    echo -e "\n${RED}>> CTRL+C detected, stopping servers...${NC}" | tee -a "$LOGFILE"
    if [[ "$STARTUP_MODE" == "single" ]]; then
        "$INSTALL_DIR/stop"
    else
        # Stop all instances
        for instance in "${!SERVER_INSTANCES[@]}"; do
            local instance_dir="${SERVER_INSTANCES[$instance]}"
            if [[ -f "$instance_dir/stop" ]]; then
                echo -e "${YELLOW}   - Stopping instance: $instance${NC}"
                "$instance_dir/stop"
            fi
        done
    fi
    exit 0
}

trap trap_ctrlc INT

# Start the selected server instances
start_server_instances

# Display final status
display_final_status
